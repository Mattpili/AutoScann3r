import html
import json
import re
import subprocess
from typing import Dict, Iterable, List, Optional, Sequence, Tuple

#Regex per identificare versioni "numeriche" tipo 1.2, 1.2.3, 1.2.3.4
VERSION_RX = re.compile(r"\d+(?:\.\d+){0,3}")


def _searchsploit_json(term: str, titles_only: bool = True) -> List[Dict[str, str]]:
    """
    Esegue il comando `searchsploit` e restituisce i risultati in formato JSON.

    Args:
        term (str): Termine di ricerca da passare a searchsploit.
        titles_only (bool): Se True usa l'opzione `-t` per cercare solo nei titoli.

    Returns:
        List[Dict[str, str]]: Lista grezza di risultati così come forniti da searchsploit,
        tipicamente con chiavi come "EDB-ID", "Title", "Type", "Platform".
    """

    args = ["searchsploit"]
    if titles_only:
        args.append("-t")
    args.extend(["-j", term])
    try:
        out = subprocess.check_output(args, text=True, stderr=subprocess.DEVNULL)
        data = json.loads(out or "{}")
        return data.get("RESULTS_EXPLOIT", []) or []
    except Exception:
        return []


def _normalize_services(services: Sequence[Tuple[str, str]]) -> Iterable[Tuple[str, str]]:
    """
    Deduplica e normalizza le coppie (product, version) dei servizi.

    Args:
        services (Sequence[Tuple[str, str]]): Sequenza di coppie (product, version)

    Returns:
        Iterable[Tuple[str, str]]: Restituisce coppie normalizzate (product, version)
    """

    seen = set()
    for prod, ver in services:
        p = (str(prod or "").strip(), str(ver or "").strip())
        if not p[0]:
            continue
        if p in seen:
            continue
        seen.add(p)
        yield p


def _build_terms(product: str, version: str) -> List[str]:
    """
    Costruisce una lista di termini di ricerca per searchsploit a partire da prodotto e versione

    Args:
        product (str): Nome del prodotto/servizio (es. "nginx").
        version (str): Stringa di versione da cui estrarre la parte numerica (es. "1.20.1-1").

    Returns:
        List[str]: Lista di termini di ricerca ordinati e deduplicati.
    """

    terms: List[str] = []
    m = VERSION_RX.search(version or "")
    if m:
        full_v = m.group(0)
        parts = full_v.split(".")
        terms.append(f"{product} {full_v}")
        if len(parts) >= 2:
            terms.append(f"{product} {parts[0]}.{parts[1]}")
    terms.append(product)
    #dedup in ordine
    out, seen = [], set()
    for t in terms:
        k = t.lower()
        if k not in seen:
            seen.add(k)
            out.append(t)
    return out


def _ver_tuple(v, width: int = 4):
    """
    Converte una versione dotted in una tupla numerica a lunghezza fissa.

    Esempio:
        "1.2.3" -> (1, 2, 3, 0) se width=4

    Questo permette di confrontare facilmente versioni tramite confronto lessico-numerico.

    Args:
        v (str): Versione in formato dotted (es. "1.2.3").
        width (int): Lunghezza massima della tupla risultante (padding con zeri).

    Returns:
        Tuple[int, ...]: Tupla di interi rappresentante la versione.
    """

    nums = [int(x) for x in v.split(".") if x.isdigit() or x.isnumeric()]
    #se lo split su '.' non ha preso tutto (es. '6.6.1p1'), limita a sola parte numerica già catturata da regex
    while len(nums) < width:
        nums.append(0)
    return tuple(nums[:width])


def _cmp_versions(a, b):
    """
    Confronta due versioni

    Args:
        a (str): Prima versione da confrontare.
        b (str): Seconda versione da confrontare.

    Returns:
        int: Risultato del confronto (-1, 0, 1).
    """

    ta, tb = _ver_tuple(a), _ver_tuple(b)
    return (ta > tb) - (ta < tb)


def _title_mentions_same_or_newer(title, target_version):
    """
    Verifica se il titolo cita la versione target o una versione successiva

    Args:
        title (str): Titolo dell'exploit (output di searchsploit).
        target_version (str): Versione target da confrontare con le versioni nel titolo.

    Returns:
        bool: True se il titolo indica che l'exploit vale per la stessa versione o una successiva, False altrimenti.
    """

    m_tar = VERSION_RX.search(target_version or "")
    if not m_tar:
        return False
    target = m_tar.group(0)
    title_l = title.lower()

    for m in VERSION_RX.finditer(title):
        tok = m.group(0)  # es. '2.4.7' (da '2.4.7p1' catturiamo comunque '2.4.7')
        cmpv = _cmp_versions(tok, target)

        #contesto immediatamente prima del token (per capire il comparatore)
        left_ctx = title_l[max(0, m.start() - 16): m.start()]

        #pattern helper
        def has_any(patterns: Sequence[str]) -> bool:
            return any(p in left_ctx for p in patterns)

        #excl. solo "strictly less than" (non include la target)
        strictly_lower = ["< ", "<\t", "<\n", " before", " prior to", " earlier than"]
        inclusive_lower = ["<=", "≤", " through", " up to", " upto"]
        higher = [">=", "≥", " or later", " and later", " or higher", " and higher", " since", " after"]

        #se il token è >= target, a meno di un comparatore che escluda esplicitamente l'uguaglianza, è un match
        if cmpv >= 0:
            #se preceduto da comparatore "strictly lower", allora il token indica un limite inferiore escludente
            # (es. 'before 2.4.7' -> non include 2.4.7)
            if has_any(strictly_lower) and not has_any(inclusive_lower):
                continue
            return True

        #se il token è minore, ma è preceduto da un comparatore "higher-or-equal", il testo intende "da tok in poi"
        if cmpv < 0 and has_any(higher):
            if _cmp_versions(target, tok) >= 0:  # target >= tok
                return True

    return False


def find_exploits_same_or_newer(services,max_per_service: int = 15,):
    """
    Cerca exploit su exploit-db per i servizi indicati, filtrando quelli per stessa
    versione o versione successiva nel titolo.

    Per ogni servizio (product, version):
      1) Costruisce una lista di termini di ricerca tramite `_build_terms`.
      2) Esegue searchsploit per ogni termine.
      3) Filtra gli exploit mantenendo solo quelli per cui `_title_mentions_same_or_newer`
         restituisce True.
      4) Limita il numero di exploit per servizio a `max_per_service`.

    Args:
        services (Sequence[Tuple[str, str]]): Sequenza di coppie (product, version) da cercare.
        max_per_service (int): Numero massimo di exploit da conservare per ciascun servizio.

    Returns:
        List[Dict[str, object]]: Lista di dizionari, uno per exploit
    """

    rows: List[Dict[str, object]] = []
    for product, version in _normalize_services(services):
        terms = _build_terms(product, version)
        seen_ids: set[int] = set()
        collected: List[Dict[str, object]] = []

        for term in terms:
            items = _searchsploit_json(term, titles_only=True)
            for it in items:
                try:
                    edb_id = int(it.get("EDB-ID") or it.get("ID") or 0)
                except Exception:
                    edb_id = 0
                if not edb_id or edb_id in seen_ids:
                    continue
                title = str(it.get("Title", "")).strip()
                if not _title_mentions_same_or_newer(title, version):
                    continue
                seen_ids.add(edb_id)
                collected.append({
                    "product": product,
                    "version": version,
                    "edb_id": edb_id,
                    "title": title,
                    "url": f"https://www.exploit-db.com/exploits/{edb_id}",
                    "type": it.get("Type"),
                    "platform": it.get("Platform"),
                })
                if len(collected) >= max_per_service:
                    break
            if len(collected) >= max_per_service:
                break

        rows.extend(collected)
    return rows


def extract_title_edb_tuples(rows):
    """
    Estrae le coppie (title, edb_id) da una lista di risultati exploit.

    Args:
        rows (List[Dict[str, object]]): Lista di dizionari exploit

    Returns:
        List[Tuple[str, int]]: Lista di tuple (titolo, exploit-db ID) senza duplicati di ID.
    """

    out: List[Tuple[str, int]] = []
    seen: set[int] = set()
    for r in rows:
        edb = int(r.get("edb_id", 0) or 0)
        if not edb or edb in seen:
            continue
        seen.add(edb)
        out.append((str(r.get("title") or ""), edb))
    return out

def normalize_services_for_search(services):
    """
    Applica all'esterno la stessa normalizzazione usata internamente per i servizi.

    Args:
        services (Sequence[Tuple[str, str]]): Sequenza originale di servizi (product, version).

    Returns:
        List[Tuple[str, str]]: Lista normalizzata e deduplicata di servizi.
    """

    return list(_normalize_services(services))
